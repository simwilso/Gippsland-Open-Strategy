# CLAUDE_INSTRUCTIONS.md

## Mission
Set up the **Gippsland Open Strategy** repo as a community-friendly open source workflow:

- Non-coders submit suggestions via GitHub Issue Form.
- Community votes with üëç on Issues.
- When a PR is approved (maintainer approval OR ‚â•2 votes), it is handed off to a Claude-Flow swarm.
- The swarm may use any internal agents to generate or edit Markdown files under `/docs/**`.
- Swarm outputs come back as a PR (preferred) or commits.
- On merge, the site auto-publishes to GitHub Pages using Docusaurus, with `/docs/**` synced into `/site/docs/**`.

---

## Success Criteria
- ‚úÖ Suggestion form works for non-coders.  
- ‚úÖ Votes are tallied and gate progress.  
- ‚úÖ Approved PRs trigger the swarm.  
- ‚úÖ Swarm produces Markdown files in `/docs/**`.  
- ‚úÖ Merge publishes updated Docusaurus site.  
- ‚úÖ Only contracts/triggers live in this repo ‚Äî **no fixed agent files**.  

---

## Repository Structure to Add

In addition to existing `/TASK.md`, `/TASK2.md`, `/README.md`, and `/docs/**`, create:

/site/ (Docusaurus site)
docusaurus.config.ts
sidebars.ts
/.github/
ISSUE_TEMPLATE/suggestion.yml
workflows/discussion-sync.yml
workflows/pr-vote-gate.yml
workflows/pr-approval-to-swarm.yml
workflows/pr-qa.yml
workflows/publish.yml
/intake/
suggestion.schema.json
mapper.ts
/flows/
swarm.yaml
adapters/github.ts
contracts/swarm-request.schema.json
contracts/swarm-output.schema.json
policies/routing.yaml
VOTING.md
GOVERNANCE.md
CONTRIBUTING.md
LICENSE

yaml
Copy code

---

## GitHub Secrets
- `CLAUDE_FLOW_API_KEY` (for swarm handoff).

---

## Docusaurus Site

**/site/docusaurus.config.ts**
```ts
import { defineConfig } from '@docusaurus/types';

export default defineConfig({
  title: 'Gippsland Open Strategy',
  url: 'https://simwilso.github.io',
  baseUrl: '/Gippsland-Open-Strategy/',
  organizationName: 'simwilso',
  projectName: 'Gippsland-Open-Strategy',
  presets: [
    [
      'classic',
      {
        docs: { path: 'docs', routeBasePath: '/', sidebarPath: require.resolve('./sidebars') },
        blog: false,
      },
    ],
  ],
});
/site/sidebars.ts

ts
Copy code
export default {
  docs: [{ type: 'autogenerated', dirName: '.' }],
};
Suggestion Intake
/.github/ISSUE_TEMPLATE/suggestion.yml

yaml
Copy code
name: Suggest an improvement
description: Propose a change without using Git
labels: [suggestion]
body:
  - type: dropdown
    id: category
    attributes:
      label: Category
      options: [Spelling, Clarity, Additional Info, Strategic]
    validations: { required: true }
  - type: textarea
    id: proposal
    attributes:
      label: What should change?
      description: Paste proposed wording or describe the change
    validations: { required: true }
  - type: textarea
    id: impact
    attributes:
      label: Why it matters (business impact)
/intake/suggestion.schema.json

json
Copy code
{
  "type": "object",
  "required": ["category", "proposal"],
  "properties": {
    "category": { "type": "string" },
    "proposal": { "type": "string" },
    "impact": { "type": "string" }
  }
}
/intake/mapper.ts

ts
Copy code
#!/usr/bin/env node
// Usage: node intake/mapper.ts '<issue-json>'
const fs = require('fs');
const issue = JSON.parse(process.argv[2] || '{}');
const body = issue.body || '';
const out = { category: 'Clarity', proposal: body, impact: '' };
process.stdout.write(JSON.stringify(out, null, 2));
Voting Workflow
/.github/workflows/discussion-sync.yml

yaml
Copy code
name: Discussion Sync
on:
  issues:
    types: [opened, edited, labeled]
jobs:
  sync:
    runs-on: ubuntu-latest
    permissions: { issues: write }
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            if (!issue.labels.some(l => l.name === 'suggestion')) return;
            const reactions = await github.reactions.listForIssue({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number
            });
            const up = reactions.data.filter(r => r.content === '+1').length;
            const labels = issue.labels.map(l => l.name).filter(n => !n.startsWith('votes:'));
            labels.push(`votes:${up}`);
            await github.issues.update({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, labels
            });
/.github/workflows/pr-vote-gate.yml

yaml
Copy code
name: PR Vote Gate
on:
  pull_request_review:
    types: [submitted]
jobs:
  gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const reviews = await github.pulls.listReviews({owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number});
            const approved = reviews.data.some(r => r.state === 'APPROVED');
            if (approved) {
              await github.issues.addLabels({owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, labels: ['ready-for-swarm']});
            }
Swarm Contracts
/flows/contracts/swarm-request.schema.json

json
Copy code
{ "type": "object", "required": ["repo","baseBranch","prNumber","changedFiles","intent"] }
/flows/contracts/swarm-output.schema.json

json
Copy code
{ "type": "object", "required": ["strategy","branchName"] }
/flows/policies/routing.yaml

yaml
Copy code
- when:
    changes_include: ["TASK.md","TASK2.md"]
  intent: "task_update"
  send_paths: ["TASK.md","TASK2.md","docs/"]
- when:
    changes_include_glob: ["docs/**/*.md"]
  intent: "doc_edit"
  send_paths: ["docs/"]
/flows/swarm.yaml

yaml
Copy code
version: 1
entry:
  input_contract: "./flows/contracts/swarm-request.schema.json"
  output_contract: "./flows/contracts/swarm-output.schema.json"
PR ‚Üí Swarm Workflow
/.github/workflows/pr-approval-to-swarm.yml

yaml
Copy code
name: PR Approval ‚Üí Swarm
on:
  pull_request:
    types: [labeled]
jobs:
  run-swarm:
    if: contains(join(github.event.pull_request.labels.*.name), 'ready-for-swarm')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo '{"strategy":"open_new_pr","branchName":"swarm/output","summary":"MVP","artifacts":[{"path":"docs/generated.md","content":"# Generated"}]}' > swarm-output.json
      - run: node ./flows/adapters/github.ts apply swarm-output.json
/flows/adapters/github.ts

ts
Copy code
#!/usr/bin/env node
import fs from 'fs'; import { execSync } from 'child_process';
const out = JSON.parse(fs.readFileSync(process.argv[2],'utf8'));
const branch = out.branchName;
execSync(`git config user.name "github-actions[bot]"`);
execSync(`git config user.email "github-actions[bot]@users.noreply.github.com"`);
execSync(`git checkout -b "${branch}"`);
for (const a of out.artifacts||[]) { fs.mkdirSync(require('path').dirname(a.path),{recursive:true}); fs.writeFileSync(a.path,a.content); execSync(`git add "${a.path}"`); }
execSync(`git commit -m "Swarm output: ${out.summary}"`); execSync(`git push origin "${branch}"`);
QA & Publish
/.github/workflows/pr-qa.yml

yaml
Copy code
name: PR QA
on: [pull_request]
jobs:
  qa:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm i -g markdownlint-cli2
      - run: markdownlint-cli2 "**/*.md"
/.github/workflows/publish.yml

yaml
Copy code
name: Publish Site
on:
  push:
    branches: [main]
jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: rsync -av docs/ site/docs/
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - run: cd site && npm ci || npm i
      - run: cd site && npm run build || npx docusaurus build
      - uses: actions/upload-pages-artifact@v3
        with: { path: site/build }
      - uses: actions/deploy-pages@v4
Governance
VOTING.md

csharp
Copy code
Vote with üëç on Issues.
A PR is approved if:
- Maintainer approves, OR
- Issue has ‚â•2 üëç.
Approved PRs trigger swarm.
CONTRIBUTING.md

Click ‚ÄúNew Issue ‚Üí Suggest an improvement‚Äù.

Paste proposal.

Add üëç to support others.

Track status via labels.

GOVERNANCE.md

Maintainers manage approvals.

Community votes guide direction.

LICENSE

MIT or Apache-2.0 recommended.

Demo Script
Create a suggestion Issue.

Add 2 üëç or have maintainer approve a PR.

Label ‚Üí ready-for-swarm.

Swarm workflow runs, outputs new /docs/generated.md.

Merge ‚Üí Pages deploy updates to site.

Swarm Notes
You may spawn any internal agents.

Always return summary and artifacts in swarm-output.json.

Prefer new PRs for large outputs.